{"totalbranchlevel":2,"branchnum":5,"term_id":47,"name":"散列函数","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"","content":"<tbody>\n <tr> \n  <td class=\"mbox-image\"> \n   <div style=\"width: 52px;\">\n    <a class=\"image\" href=\"/wiki/File:Mergefrom.svg\"><img width=\"50\" height=\"20\" alt=\"Mergefrom.svg\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Mergefrom.svg/50px-Mergefrom.svg.png\" data-file-height=\"20\" data-file-width=\"50\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Mergefrom.svg/75px-Mergefrom.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Mergefrom.svg/100px-Mergefrom.svg.png 2x\" /></a>\n   </div> </td> \n  <td class=\"mbox-text\"><span class=\"mbox-text-span\">建议将<b><a title=\"散列\" href=\"/wiki/%E6%95%A3%E5%88%97\">散列</a></b><a title=\"Wikipedia:重复条目\" class=\"mw-redirect\" href=\"/wiki/Wikipedia:%E9%87%8D%E5%A4%8D%E6%9D%A1%E7%9B%AE\">并入</a>本条目或章节。（<a title=\"Talk:散列函数\" href=\"/wiki/Talk:%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8\">讨论</a>） <span class=\"hide-when-compact\"><br /></span> </span></td> \n </tr> \n</tbody>","fragment_id":"摘要_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"<div class=\"noteTA-title\" data-noteta-code=\"zh-hans:散列函数; zh-hant:雜湊函數;\"></div> \n<div class=\"noteTA-group\"> \n <div data-noteta-group=\"IT\" data-noteta-group-source=\"module\"></div> \n</div> \n<div class=\"noteTA-local\"> \n <div data-noteta-code=\"zh-hans:散列; zh-hant:雜湊;\"></div> \n <div data-noteta-code=\"zh-hans:数据; zh-hant:資料;\"></div> \n <div data-noteta-code=\"zh-hans:创建; zh-hant:建立;\"></div> \n <div data-noteta-code=\"zh-hans:字符串; zh-hant:字串;\"></div> \n <div data-noteta-code=\"zh-hans:[[比特]]; zh-hant:[[位元]];\"></div> \n <div data-noteta-code=\"zh-hans:健壮; zh-hant:強韌;\"></div> \n</div>","fragment_id":"摘要_2","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"<b>散列函数</b>（或<b>散列算法</b>，又称<b>哈希函数</b>，<span class=\"LangWithName\">英语：<span lang=\"en\" xml:lang=\"en\">Hash Function</span></span>）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a title=\"函数\" href=\"/wiki/%E5%87%BD%E6%95%B0\">函数</a>将数据打乱混合，重新创建一个叫做<b>散列值</b>（<span lang=\"en\" xml:lang=\"en\">hash values</span>，<span lang=\"en\" xml:lang=\"en\">hash codes</span>，<span lang=\"en\" xml:lang=\"en\">hash sums</span>，或<span lang=\"en\" xml:lang=\"en\">hashes</span>）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现<a title=\"散列冲突（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81&amp;action=edit&amp;redlink=1\">散列冲突</a>。在<a title=\"散列表\" class=\"mw-redirect\" href=\"/wiki/%E6%95%A3%E5%88%97%E8%A1%A8\">散列表</a>和<a title=\"数据处理（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86&amp;action=edit&amp;redlink=1\">数据处理</a>中，不抑制冲突来区别数据，会使得<a title=\"数据库记录（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%B0%E5%BD%95&amp;action=edit&amp;redlink=1\">数据库记录</a>更难找到。","fragment_id":"摘要_3","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"<div class=\"thumbinner\" style=\"width: 332px;\">\n <a class=\"image\" href=\"/wiki/File:Hash_function.svg\"><img width=\"330\" height=\"223\" class=\"thumbimage\" alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/d/da/Hash_function.svg/330px-Hash_function.svg.png\" data-file-height=\"352\" data-file-width=\"520\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/d/da/Hash_function.svg/495px-Hash_function.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/da/Hash_function.svg/660px-Hash_function.svg.png 2x\" /></a> \n <div class=\"thumbcaption\"> \n  <div class=\"magnify\">\n   <a title=\"放大\" class=\"internal\" href=\"/wiki/File:Hash_function.svg\"></a>\n  </div> 散列函数的工作原理\n </div> \n</div>","fragment_id":"摘要_4","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"散列函数的性质","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"所有散列函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有<a title=\"确定性\" class=\"mw-redirect\" href=\"/wiki/%E7%A1%AE%E5%AE%9A%E6%80%A7\">确定性</a>的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“<a title=\"散列碰撞（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E9%9B%9C%E6%B9%8A%E7%A2%B0%E6%92%9E&amp;action=edit&amp;redlink=1\">散列碰撞</a>（collision）”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。","fragment_id":"散列函数的性质_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"典型的散列函数都有非常大的<a title=\"定义域\" href=\"/wiki/%E5%AE%9A%E4%B9%89%E5%9F%9F\">定义域</a>，比如<a title=\"SHA-2\" href=\"/wiki/SHA-2\">SHA-2</a>最高接受(2<sup>64</sup>-1)/8长度的<a title=\"字节\" href=\"/wiki/%E5%AD%97%E8%8A%82\">字节</a><a title=\"字符串\" href=\"/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2\">字符串</a>。同时散列函数一定有着有限的<a title=\"值域\" href=\"/wiki/%E5%80%BC%E5%9F%9F\">值域</a>，比如固定长度的<a title=\"比特\" class=\"mw-disambig\" href=\"/wiki/%E6%AF%94%E7%89%B9\">比特</a>串。在某些情况下，散列函数可以设计成具有相同大小的定义域和值域间的<a title=\"单射\" href=\"/wiki/%E5%8D%95%E5%B0%84\">单射</a>。散列函数必须不具有可逆性。","fragment_id":"散列函数的性质_2","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":1,"facet_name":"散列函数的应用","totalbranchnum":6,"type":"branch","totalleafnum":6,"children":[{"totalbranchlevel":0,"facet_name":"加密","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"一个典型的加密<a title=\"单向函数\" href=\"/wiki/%E5%96%AE%E5%90%91%E5%87%BD%E6%95%B8\">单向函数</a>是“非对称”的，并且由一个高效的散列函数构成；一个典型的加密<a title=\"暗门函数（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E6%9A%97%E9%97%A8%E5%87%BD%E6%95%B0&amp;action=edit&amp;redlink=1\">暗门函数</a>是“对称”的，并且由一个高效的随机函数构成。","fragment_id":"加密_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"确保传递真实的信息","totalbranchnum":0,"type":"branch","totalleafnum":0,"children":[]},{"totalbranchlevel":0,"facet_name":"散列表","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"","content":"散列表是散列函数的一个主要应用，使用散列表能够快速的按照<i>关键字</i>查找数据记录。（注意：关键字不是像在<a title=\"加密\" href=\"/wiki/%E5%8A%A0%E5%AF%86\">加密</a>中所使用的那样是秘密的，但它们都是用来“解锁”或者访问数据的。）例如，在英语字典中的关键字是英文单词，和它们相关的记录包含这些单词的定义。在这种情况下，散列函数必须把按照字母顺序排列的字符串映射到为散列表的内部<a title=\"数组\" href=\"/wiki/%E6%95%B0%E7%BB%84\">数组</a>所创建的索引上。","fragment_id":"散列表_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"散列表散列函数的几乎不可能/不切实际的理想是把每个关键字映射到唯一的索引上（参考<a title=\"完美散列\" href=\"/wiki/%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97\">完美散列</a>），因为这样能够保证直接访问表中的每一个数据。","fragment_id":"散列表_2","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"一个好的散列函数（包括大多数<a title=\"加密散列函数\" class=\"mw-redirect\" href=\"/wiki/%E5%8A%A0%E5%AF%86%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\">加密散列函数</a>）具有均匀的真正随机输出，因而平均只需要一两次探测（依赖于<a title=\"装填因子（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90&amp;action=edit&amp;redlink=1\">装填因子</a>）就能找到目标。同样重要的是，随机散列函数不太会出现非常高的<a title=\"冲突率（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E5%86%B2%E7%AA%81%E7%8E%87&amp;action=edit&amp;redlink=1\">冲突率</a>。但是，少量的可以估计的冲突在实际状况下是不可避免的（参考<a title=\"生日悖论\" class=\"mw-redirect\" href=\"/wiki/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA\">生日悖论</a>或<a title=\"鸽洞原理\" class=\"mw-redirect\" href=\"/wiki/%E9%B4%BF%E6%B4%9E%E5%8E%9F%E7%90%86\">鸽洞原理</a>）。","fragment_id":"散列表_3","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"在很多情况下，<a title=\"Heuristic (computer science)（页面不存在）\" class=\"new\" href=\"/w/index.php?title=Heuristic_(computer_science)&amp;action=edit&amp;redlink=1\">heuristic</a>散列函数所产生的冲突比随机散列函数少的多。Heuristic函数利用了相似关键字的<a title=\"相似性（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E7%9B%B8%E4%BC%BC%E6%80%A7&amp;action=edit&amp;redlink=1\">相似性</a>。例如，可以设计一个heuristic函数使得像<tt>FILE0000.CHK</tt>, <tt>FILE0001.CHK</tt>, <tt>FILE0002.CHK</tt>，等等这样的文件名映射到表的连续指针上，也就是说这样的序列不会发生冲突。相比之下，对于一组好的关键字性能出色的随机散列函数，对于一组坏的关键字经常性能很差，这种坏的关键字会自然产生而不仅仅在<a title=\"攻击\" href=\"/wiki/%E6%94%BB%E6%93%8A\">攻击</a>中才出现。性能不佳的散列函数表意味着查找操作会退化为费时的<a title=\"线性搜索\" href=\"/wiki/%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2\">线性搜索</a>。","fragment_id":"散列表_4","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"错误校正","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"使用一个散列函数可以很直观的检测出数据在传输时发生的错误。在数据的发送方，对将要发送的数据应用散列函数，并将计算的结果同原始数据一同发送。在数据的接收方，同样的散列函数被再一次应用到接收到的数据上，如果两次散列函数计算出来的结果不一致，那么就说明数据在传输的过程中某些地方有错误了。这就叫做<a title=\"冗余校验\" href=\"/wiki/%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C\">冗余校验</a>。","fragment_id":"错误校正_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"校正错误时，至少会对可能出现的扰动大致假定一个分布模式。对于一个信息串的微扰可以被分为两类，大的（不可能的）错误和小的（可能的）错误。我们对于第二类错误重新定义如下，假如给定H（x）和x+s，那么只要s足够小，我们就能有效的计算出x。那样的散列函数被称作错误校正编码。这些错误校正编码有两个重要的分类：<a title=\"循环冗余校验\" class=\"mw-redirect\" href=\"/wiki/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C\">循环冗余校验</a>和<a title=\"里德-所罗门码\" href=\"/wiki/%E9%87%8C%E5%BE%B7-%E6%89%80%E7%BD%97%E9%97%A8%E7%A0%81\">里德-所罗门码</a>。","fragment_id":"错误校正_2","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"语音识别","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"对于像从一个已知列表中匹配一个MP3文件这样的应用，一种可能的方案是使用传统的散列函数——例如<a title=\"MD5\" href=\"/wiki/MD5\">MD5</a>，但是这种方案会对时间平移、CD读取错误、不同的音频压缩算法或者音量调整的实现机制等情况非常敏感。使用一些类似于MD5的方法有利于迅速找到那些严格相同（从音频文件的二进制数据来看）的音频文件，但是要找到全部相同（从音频文件的内容来看）的音频文件就需要使用其他更高级的算法了。","fragment_id":"语音识别_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"那些并不紧随IT工业潮流的人往往能反其道而行之，对于那些微小差异足够健壮的散列函数确实存在。现存的绝大多数散列算法都是不够健壮的，但是有少数散列算法能够达到辨别从嘈杂房间里的扬声器里播放出来的音乐的健壮性。有一个实际的例子是<a title=\"Shazam Entertainment（页面不存在）\" class=\"new\" href=\"/w/index.php?title=Shazam_Entertainment&amp;action=edit&amp;redlink=1\">Shazam</a><a class=\"external autonumber\" href=\"http://www.shazam.com/\" rel=\"nofollow\">[1]</a> 服务。用户可以用手机打开其app，并将话筒靠近用于播放音乐的扬声器。该项服务会分析正在播放的音乐，并将它于存储在数据库中的已知的散列值进行比较。用户就能够收到被识别的音乐的曲名。","fragment_id":"语音识别_2","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"Rabin-Karp字符串搜索算法","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"<a title=\"Rabin-Karp字符串搜索算法（页面不存在）\" class=\"new\" href=\"/w/index.php?title=Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1\">Rabin-Karp字符串搜索算法</a>是一个相对快速的<a title=\"字符串搜索算法\" class=\"mw-redirect\" href=\"/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95\">字符串搜索算法</a>，它所需要的平均搜索时间是<a title=\"大O符号\" href=\"/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\">O(n)</a>.这个算法是创建在使用散列来比较字符串的基础上的。","fragment_id":"Rabin-Karp字符串搜索算法_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]}]},{"totalbranchlevel":0,"facet_name":"术语来源","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"","content":"<span id=\"参阅\"></span><span class=\"mw-headline\" id=\".E5.8F.82.E9.98.85\">参阅</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a title=\"编辑小节：参阅\" href=\"/w/index.php?title=%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8&amp;action=edit&amp;section=10\">编辑</a><span class=\"mw-editsection-bracket\">]</span></span>","fragment_id":"术语来源_1","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"<span id=\"参考资料\"></span><span class=\"mw-headline\" id=\".E5.8F.82.E8.80.83.E8.B5.84.E6.96.99\">参考资料</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a title=\"编辑小节：参考资料\" href=\"/w/index.php?title=%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8&amp;action=edit&amp;section=11\">编辑</a><span class=\"mw-editsection-bracket\">]</span></span>","fragment_id":"术语来源_2","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"<span id=\"外部链接\"></span><span class=\"mw-headline\" id=\".E5.A4.96.E9.83.A8.E9.93.BE.E6.8E.A5\">外部链接</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a title=\"编辑小节：外部链接\" href=\"/w/index.php?title=%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8&amp;action=edit&amp;section=12\">编辑</a><span class=\"mw-editsection-bracket\">]</span></span>","fragment_id":"术语来源_3","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"},{"url":"","content":"<li><a class=\"external text\" href=\"http://www.sigma.me/2011/09/13/hash-and-bloom-filter.html\" rel=\"nofollow\">Hash和Bloom Filter介绍</a></li> \n<li><a class=\"external text\" href=\"http://www.partow.net/programming/hashfunctions/index.html\" rel=\"nofollow\">General purpose hash function algorithms C/C++/Pascal/Java/Ruby</a></li> \n<li><a class=\"external text\" href=\"http://burtleburtle.net/bob/hash/evahash.html\" rel=\"nofollow\">Hash Functions for Hash Table Lookup</a> by Bob Jenkins</li> \n<li><a class=\"external text\" href=\"http://www.azillionmonkeys.com/qed/hash.html\" rel=\"nofollow\">散列函数</a>by Paul Hsieh</li> \n<li><a class=\"external text\" href=\"http://www.rsasecurity.com/rsalabs/node.asp?id=2176\" rel=\"nofollow\">什么是散列函数?</a> from RSA Laboratories</li> \n<li><a class=\"external text\" href=\"http://www.paulschou.com/tools/xlate/\" rel=\"nofollow\">Online Char（ASCII）,HEX, Binary, Base64, etc... Encoder/Decoder with MD2, MD4, MD5, SHA1+2, etc. hashing algorithms</a></li> \n<li><a class=\"external text\" href=\"http://3amsystems.com/monetics/crypto.php\" rel=\"nofollow\">Crypto-Toolbox</a> - Online cryptography, hashing and PIN block sanity checking for EftPos developers.</li> \n<li><a class=\"external text\" href=\"http://www.fileformat.info/tool/hash.htm\" rel=\"nofollow\">Hash值在线计算</a></li>","fragment_id":"术语来源_4","scratchTime":"2017-10-28 15:35:30.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"参阅","totalbranchnum":0,"type":"branch","totalleafnum":0,"children":[]}]}