{"totalbranchlevel":2,"branchnum":7,"term_id":50,"name":"抽象资料型别","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"","content":"<div class=\"noteTA-group\"> \n <div data-noteta-group=\"IT\" data-noteta-group-source=\"module\"></div> \n</div> \n<div class=\"noteTA-local\"> \n <div data-noteta-code=\"zh:型別;zh-tw:型別;zh-cn:类型;\"></div> \n <div data-noteta-code=\"zh:資料;zh-tw:資料;zh-cn:数据;\"></div> \n <div data-noteta-code=\"zh:程式;zh-tw:程式;zh-cn:程序;\"></div> \n <div data-noteta-code=\"zh:實作;zh-tw:實作;zh-cn:实现;\"></div> \n <div data-noteta-code=\"zh:物件;zh-tw:物件;zh-cn:对象;\"></div> \n <div data-noteta-code=\"zh:陣列;zh-tw:陣列;zh-cn:数组;\"></div> \n <div data-noteta-code=\"zh:佇列;zh-tw:佇列;zh-cn:队列;\"></div> \n</div>","fragment_id":"摘要_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"<b>抽象数据类型</b>（<b>A</b>bstract <b>D</b>ata <b>T</b>ype，<b>ADT</b>）是<a title=\"计算机科学\" href=\"/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\">计算机科学</a>中具有类似行为的特定类别的<a title=\"数据结构\" href=\"/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">数据结构</a>的<a title=\"数学模型\" href=\"/wiki/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B\">数学模型</a>；或者具有类似语义的一种或多种<a title=\"程序设计语言\" class=\"mw-redirect\" href=\"/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80\">程序设计语言</a>的<a title=\"数据类型\" class=\"mw-redirect\" href=\"/wiki/%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B\">数据类型</a>。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。","fragment_id":"摘要_2","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"例如，抽象的<a title=\"堆栈\" class=\"mw-redirect\" href=\"/wiki/%E5%A0%86%E7%96%8A\">堆栈</a>（stack）由3个操作定义：推入push，弹出pop（接受约束：每次弹出返回的是最新被推入且没有被弹出的数据，也就是后进先出），查看堆栈顶端数据peek。当分析使用堆栈算法的效率，所有这3个操作用时相同，无论堆栈中包含多少项数据；并且对每项数据栈使用了常量大小的存储。","fragment_id":"摘要_3","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"抽象数据类型（ADT）是纯粹理论实体，用于简化描述抽象算法，分类与评价数据结构，形式描述程序设计语言的类型系统。一个ADT可以用特定数据类型或数据结构实现，在许多程序设计语言中有许多种实现方式；或者用形式规范语言描述。ADT常实现为模块（module）：模块的接口声明了对应于ADT操作的例程（procedure），有时用注释描述了约束。","fragment_id":"摘要_4","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"示例","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"<li><a title=\"关联数组\" href=\"/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\">关联数组</a></li> \n<li><a title=\"复数\" class=\"mw-redirect\" href=\"/wiki/%E8%A4%87%E6%95%B8\">复数</a></li> \n<li><a title=\"容器 (数据结构)\" class=\"mw-redirect\" href=\"/wiki/%E5%AE%B9%E5%99%A8_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\">容器</a></li> \n<li><a title=\"双端队列\" class=\"mw-redirect\" href=\"/wiki/%E9%9B%99%E7%AB%AF%E4%BD%87%E5%88%97\">双端队列</a></li> \n<li><a title=\"串列 (抽象数据类型)\" href=\"/wiki/%E4%B8%B2%E5%88%97_(%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)\">列表</a></li> \n<li><a title=\"Multimap\" class=\"mw-redirect\" href=\"/wiki/Multimap\">Multimap</a></li> \n<li><a title=\"优先队列\" href=\"/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97\">优先队列</a></li> \n<li><a title=\"队列\" class=\"mw-redirect\" href=\"/wiki/%E4%BD%87%E5%88%97\">队列</a></li> \n<li><a title=\"集合 (计算机科学)\" href=\"/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\">集合</a></li> \n<li><a title=\"堆栈\" class=\"mw-redirect\" href=\"/wiki/%E5%A0%86%E7%96%8A\">堆栈</a></li> \n<li><a title=\"字符串\" class=\"mw-redirect\" href=\"/wiki/%E5%AD%97%E4%B8%B2\">字符串</a></li> \n<li><a title=\"树 (数据结构)\" class=\"mw-redirect\" href=\"/wiki/%E6%A8%B9_(%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)\">树</a></li>","fragment_id":"示例_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"接口和实现的分离","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"","content":"实现于程序时，抽象数据类型只显现出其接口，并将实现加以隐藏。用户只需关心它的接口，而不是如何实现。未来更可以改变实现的方式。（其支持<a title=\"信息隐藏\" class=\"mw-redirect\" href=\"/wiki/%E8%B3%87%E8%A8%8A%E9%9A%B1%E8%97%8F\">信息隐藏</a>原理，或保护程序免受变化的冲击。）","fragment_id":"接口和实现的分离_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"在抽象数据类型和数据结构之间，有一个实现上的微妙差别。例如，列表的抽象数据类型可以数组为基础、或者使用链表来实现。列表即是一种具良好运算（加入元素、移除元素等等）定义的抽象数据类型。链表是以指针为基础的数据结构，且可用来创建一个列表。链表常用于列表的抽象数据类型。","fragment_id":"接口和实现的分离_2","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"从实现中分离出接口，并不表示用户不该知道实现的方法，而是用户不能依赖于实现细节。例如，一个抽象数据类型可以用脚本语言创建，或其它可以被反编译的语言（如 <a title=\"C语言\" class=\"mw-redirect\" href=\"/wiki/C%E8%AA%9E%E8%A8%80\">C语言</a>）。即使用户可发现实现的方法，只要所有客户端程序遵循该接口，且改变实现方式时不会产生影响，那就仍是抽象数据类型。","fragment_id":"接口和实现的分离_3","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"在面向对象的用语中，抽象数据类型相当于<a title=\"类别\" class=\"mw-disambig\" href=\"/wiki/%E9%A1%9E%E5%88%A5\">类别</a>；抽象数据类型的实体就相当于<a title=\"对象 (计算机科学)\" class=\"mw-redirect\" href=\"/wiki/%E7%89%A9%E4%BB%B6_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)\">对象</a>。某些语言包含了用于宣告抽象数据类型的构造函数。例如，C++ 和 Java 为此提供了类的构造函数。","fragment_id":"接口和实现的分离_4","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"抽象数据结构","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"<b>抽象数据结构</b>即根据所要运算的数据以及其<a title=\"计算复杂性\" class=\"mw-redirect\" href=\"/wiki/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7\">计算复杂性</a>所定义的抽象存储区，而不关心具体的<a title=\"数据结构\" class=\"mw-redirect\" href=\"/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B\">数据结构</a>的实现。","fragment_id":"抽象数据结构_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"这个概念与<a title=\"编程语言\" class=\"mw-redirect\" href=\"/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80\">编程语言</a>理论中所使用的抽象数据<b>类型</b>非常接近，大致上抽象数据结构和抽象数据类型的名称，和具体的数据结构的名称一致。","fragment_id":"抽象数据结构_2","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"内置抽象数据类型","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"一部分抽象数据类型在程序设计中相当普遍且实用，所以在某些编程语言中，成为原生类型、或加进标准库中。例如，Perl 的数组可以用列表或双端队列之类的抽象数据类型来实现，散列表也可以用 Map 或 Table 来做。C++ 标准库和 Java 库也提供了列表、堆栈、队列、Map、优先权队列和字符串。","fragment_id":"内置抽象数据类型_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":1,"facet_name":"实际示例","totalbranchnum":2,"type":"branch","totalleafnum":2,"children":[{"totalbranchlevel":0,"facet_name":"作为抽象数据类型的有理数","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"<a title=\"有理数\" class=\"mw-redirect\" href=\"/wiki/%E6%9C%89%E7%90%86%E6%95%B8\">有理数</a>（可以 a/b 格式表示的数，且 a 和 b 都是整数）本来是不能在电脑中表示出来。不过可以合理的抽象数据类型来定义，如下。","fragment_id":"作为抽象数据类型的有理数_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"堆栈","totalbranchnum":0,"type":"branch","totalleafnum":4,"children":[{"url":"","content":"long stack_create(); /* 建立新的堆疊實體 */\nvoid stack_push(long stack, void *item); /* 將一個項目堆入堆疊 */\nvoid *stack_pop(long stack); /* 從堆疊頂部取得項目 */\nvoid stack_delete(long stack); /* 刪除堆疊 */","fragment_id":"接口_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"上述堆栈的抽象数据类型，一开始可以使用数组来实现，然后改用链表，而不会伤到任何用户的代码。有多少方法可以实现抽象数据类型，取决于编程语言。例如，上述示例可使用 C 编写一个结构，以及随同的一组数据结构，可使用数组或链表来存放记录；当构造函数函数返回一个抽象句柄时，就对用户隐藏了真实的实现过程。","fragment_id":"各种实现_1","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"<span id=\"參閱\"></span><span class=\"mw-headline\" id=\".E5.8F.83.E9.96.B1\">参阅</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a title=\"编辑小节：参阅\" href=\"/w/index.php?title=%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5&amp;action=edit&amp;section=11\">编辑</a><span class=\"mw-editsection-bracket\">]</span></span>","fragment_id":"各种实现_2","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"},{"url":"","content":"<tbody>\n <tr> \n  <td style=\"padding: 2px;\"> \n   <table class=\"nowraplinks hlist navbox-inner\" style=\"background: none; color: inherit; border-spacing: 0;\" cellspacing=\"0\"> \n    <tbody>\n     <tr> \n      <th class=\"navbox-group\" scope=\"row\"><a title=\"权威控制\" href=\"/wiki/%E6%AC%8A%E5%A8%81%E6%8E%A7%E5%88%B6\">规范控制</a></th> \n      <td class=\"navbox-list navbox-odd\" style=\"padding: 0px; width: 100%; text-align: left; border-left-width: 2px; border-left-style: solid;\"> \n       <div style=\"padding: 0em 0.25em;\"> \n        <ul> \n         <li><a title=\"集成规范文档\" href=\"/wiki/%E6%95%B4%E5%90%88%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3\">GND</a>: <span class=\"uid\"><a class=\"external text\" href=\"http://d-nb.info/gnd/4120827-4\" rel=\"nofollow\">4120827-4</a></span></li> \n        </ul> \n       </div> </td> \n     </tr> \n    </tbody>\n   </table> </td> \n </tr> \n</tbody>","fragment_id":"各种实现_3","scratchTime":"2017-10-28 15:35:56.0","type":"leaf","flag":"fragment"}]}]},{"totalbranchlevel":0,"facet_name":"参阅","totalbranchnum":0,"type":"branch","totalleafnum":0,"children":[]}]}