{"totalbranchlevel":2,"branchnum":1,"term_id":56,"name":"双向链表","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"<div class=\"mw-parser-output\">\n <div class=\"noteTA\" id=\"noteTA-4bec5907\"> \n  <div class=\"noteTA-title\" data-noteta-code=\"zh-hans:双向链表; zh-hant:雙向連結串列;\"></div> \n  <div class=\"noteTA-group\"> \n   <div data-noteta-group=\"IT\" data-noteta-group-source=\"module\"></div> \n  </div> \n  <div class=\"noteTA-local\"> \n   <div data-noteta-code=\"zh-hans:双链表; zh-hant:雙連結串列;\"></div> \n   <div data-noteta-code=\"zh-hans:指针; zh-hant:指標;\"></div> \n  </div> \n </div> \n <p><b>双向链表</b>也叫<b>双链表</b>，是<a title=\"链表\" href=\"/wiki/%E9%93%BE%E8%A1%A8\">链表</a>的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向<a title=\"循环链表\" href=\"/wiki/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\">循环链表</a>。</p> \n <pre>/* 线性表的双向链表存储结构 */\ntypedef struct DuLNode\n{\n  ElemType data;\n  struct DuLNode *prior,*next;\n}DuLNode,*DuLinkList;\n</pre> \n <pre>/*带头结点的双向循环链表的基本操作(14个) */\nvoid InitList(DuLinkList *L)\n{ /* 产生空的双向循环链表L */\n  *L=(DuLinkList)malloc(sizeof(DuLNode));\n  if(*L)\n    (*L)-&gt;next=(*L)-&gt;prior=*L;\n  else\n    exit(OVERFLOW);\n}\n</pre> \n <pre>void DestroyList(DuLinkList *L)\n{ /* 操作结果：销毁双向循环链表L */\n  DuLinkList q,p=(*L)-&gt;next; /* p指向第一个结点 */\n  while(p!=*L) /* p没到表头 */\n  {\n    q=p-&gt;next;\n    free(p);\n    p=q;\n  }\n  free(*L);\n  *L=NULL;\n}\n</pre> \n <pre>void ClearList(DuLinkList L) /* 不改变L */\n{ /* 初始条件：L已存在。操作结果：将L重置为空表 */\n  DuLinkList q,p=L-&gt;next; /* p指向第一个结点 */\n  while(p!=L) /* p没到表头 */\n  {\n    q=p-&gt;next;\n    free(p);\n    p=q;\n  }\n  L-&gt;next=L-&gt;prior=L; /* 头结点的两个指针域均指向自身 */\n}\n</pre> \n <pre>Status ListEmpty(DuLinkList L)\n{ /* 初始条件：线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */\n  if(L-&gt;next==L&amp;&amp;L-&gt;prior==L)\n    return TRUE;\n  else\n    return FALSE;\n}\n</pre> \n <pre>int ListLength(DuLinkList L)\n{ /* 初始条件：L已存在。操作结果：返回L中数据元素个数 */\n  int i=0;\n  DuLinkList p=L-&gt;next; /* p指向第一个结点 */\n  while(p!=L) /* p没到表头 */\n  {\n    i++;\n    p=p-&gt;next;\n  }\n  return i;\n}\n</pre> \n <pre>Status GetElem(DuLinkList L,int i,ElemType *e)\n{ /* 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR */\n  int j=1; /* j为计数器 */\n  DuLinkList p=L-&gt;next; /* p指向第一个结点 */\n  while(p!=L&amp;&amp;j&lt;i) /* 顺指针向后查找，直到p指向第i个元素或p指向头结点 */\n  {\n    p=p-&gt;next;\n    j++;\n  }\n  if(p==L||j&gt;i) /* 第i个元素不存在 */\n    return ERROR;\n  *e=p-&gt;data; /* 取第i个元素 */\n  return OK;\n}\n</pre> \n <pre>int LocateElem(DuLinkList L,ElemType e,Status(*compare)(ElemType,ElemType))\n{ /* 初始条件：L已存在，compare()是数据元素判定函数 */\n  /* 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。 */\n  /*           若这样的数据元素不存在，则返回值为0 */\n  int i=0;\n  DuLinkList p=L-&gt;next; /* p指向第1个元素 */\n  while(p!=L)\n  {\n    i++;\n    if(compare(p-&gt;data,e)) /* 找到这样的数据元素 */\n      return i;\n    p=p-&gt;next;\n  }\n  return 0;\n}\n</pre> \n <pre>Status PriorElem(DuLinkList L,ElemType cur_e,ElemType *pre_e)\n{ /* 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱， */\n  /*           否则操作失败，pre_e无定义 */\n  DuLinkList p=L-&gt;next-&gt;next; /* p指向第2个元素 */\n  while(p!=L) /* p没到表头 */\n  {\n    if(p-&gt;data==cur_e)\n    {\n      *pre_e=p-&gt;prior-&gt;data;\n      return TRUE;\n    }\n    p=p-&gt;next;\n  }\n  return FALSE;\n}\n</pre> \n <pre>Status NextElem(DuLinkList L,ElemType cur_e,ElemType *next_e)\n{ /* 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继， */\n  /*           否则操作失败，next_e无定义 */\n  DuLinkList p=L-&gt;next-&gt;next; /* p指向第2个元素 */\n  while(p!=L) /* p没到表头 */\n  {\n    if(p-&gt;prior-&gt;data==cur_e)\n    {\n      *next_e=p-&gt;data;\n      return TRUE;\n    }\n    p=p-&gt;next;\n  }\n  return FALSE;\n}\n</pre> \n <pre>DuLinkList GetElemP(DuLinkList L,int i) /* 另加 */\n{ /* 在双向链表L中返回第i个元素的地址。i为0，返回头结点的地址。若第i个元素不存在，*/\n  /* 返回NULL */\n  int j;\n  DuLinkList p=L; /* p指向头结点 */\n  if(i&lt;0||i&gt;ListLength(L)) /* i值不合法 */\n    return NULL;\n  for(j=1;j&lt;=i;j++)\n    p=p-&gt;next;\n  return p;\n}\n</pre> \n <pre>Status ListInsert(DuLinkList L,int i,ElemType e)\n{ /* 在带头结点的双链循环线性表L中第i个位置之前插入元素e，i的合法值为1≤i≤表长+1 */\n  /* 改进算法2.18，否则无法在第表长+1个结点之前插入元素 */\n  DuLinkList p,s;\n  if(i&lt;1||i&gt;ListLength(L)+1) /* i值不合法 */\n    return ERROR;\n  p=GetElemP(L,i-1); /* 在L中确定第i个元素前驱的位置指针p */\n  if(!p) /* p=NULL,即第i个元素的前驱不存在(设头结点为第1个元素的前驱) */\n    return ERROR;\n  s=(DuLinkList)malloc(sizeof(DuLNode));\n  if(!s)\n    return OVERFLOW;\n  s-&gt;data=e;\n  s-&gt;prior=p; /* 在第i-1个元素之后插入 */\n  s-&gt;next=p-&gt;next;\n  p-&gt;next-&gt;prior=s;\n  p-&gt;next=s;\n  return OK;\n}\n</pre> \n <pre>Status ListDelete(DuLinkList L,int i,ElemType *e)\n{ /* 删除带头结点的双链循环线性表L的第i个元素，i的合法值为1≤i≤表长 */\n  DuLinkList p;\n  if(i&lt;1) /* i值不合法 */\n    return ERROR;\n  p=GetElemP(L,i);  /* 在L中确定第i个元素的位置指针p */\n  if(!p) /* p=NULL,即第i个元素不存在 */\n    return ERROR;\n  *e=p-&gt;data;\n  p-&gt;prior-&gt;next=p-&gt;next;//此处好像并没有考虑链表头，链表尾。 好人看到后请改正一下~\n  p-&gt;next-&gt;prior=p-&gt;prior;\n  free(p);\n  return OK;\n}\n</pre> \n <pre>void ListTraverse(DuLinkList L,void(*visit)(ElemType))\n{ /* 由双链循环线性表L的头结点出发，正序对每个数据元素调用函数visit() */\n  DuLinkList p=L-&gt;next; /* p指向头结点 */\n  while(p!=L)\n  {\n    visit(p-&gt;data);\n    p=p-&gt;next;\n  }\n  printf(&quot;\\n&quot;);\n}\n</pre> \n <pre>void ListTraverseBack(DuLinkList L,void(*visit)(ElemType))\n{ /* 由双链循环线性表L的头结点出发，逆序对每个数据元素调用函数visit()。另加 */\n  DuLinkList p=L-&gt;prior; /* p指向尾结点 */\n  while(p!=L)\n  {\n    visit(p-&gt;data);\n    p=p-&gt;prior;\n  }\n  printf(&quot;\\n&quot;);\n}\n</pre> \n <!-- \nNewPP limit report\nParsed by mw1268\nCached time: 20171020172256\nCache expiry: 1900800\nDynamic content: false\nCPU time usage: 0.112 seconds\nReal time usage: 0.121 seconds\nPreprocessor visited node count: 24/1000000\nPreprocessor generated node count: 0/1500000\nPost‐expand include size: 119964/2097152 bytes\nTemplate argument size: 0/2097152 bytes\nHighest expansion depth: 2/40\nExpensive parser function count: 1/500\nLua time usage: 0.034/10.000 seconds\nLua memory usage: 1.63 MB/50 MB\n--> \n <!--\nTransclusion expansion time report (%,ms,calls,template)\n100.00%   50.123      1 Template:NoteTA\n100.00%   50.123      1 -total\n--> \n</div> \n<!-- Saved in parser cache with key zhwiki:pcache:idhash:33305-0!canonical!zh-cn and timestamp 20171020172256 and revision id 42189245\n --> \n<noscript>\n &lt;img src=&quot;//zh.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1&quot; alt=&quot;&quot; title=&quot;&quot; width=&quot;1&quot; height=&quot;1&quot; style=&quot;border: none; position: absolute;&quot; /&gt;\n</noscript>","fragment_id":"摘要_1","scratchTime":"2017-10-28 15:36:47.0","type":"leaf","flag":"fragment"}]}]}