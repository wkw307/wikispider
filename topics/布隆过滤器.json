{"totalbranchlevel":2,"branchnum":4,"term_id":48,"name":"布隆过滤器","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"<b>布隆过滤器</b>（<span class=\"LangWithName\">英语：<span lang=\"en\" xml:lang=\"en\">Bloom Filter</span></span>）是1970年由布隆提出的。它实际上是一个很长的<a title=\"二进制\" href=\"/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6\">二进制</a>向量和一系列随机<a title=\"映射函数（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0&amp;action=edit&amp;redlink=1\">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。","fragment_id":"摘要_1","scratchTime":"2017-10-28 15:35:39.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"基本概念","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。<a title=\"链表\" href=\"/wiki/%E9%93%BE%E8%A1%A8\">链表</a>、<a title=\"树 (数据结构)\" href=\"/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\">树</a>、<a title=\"散列表\" class=\"mw-redirect\" href=\"/wiki/%E6%95%A3%E5%88%97%E8%A1%A8\">散列表</a>（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n      <mo>\n       ,\n      </mo> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       log\n      </mi> \n      <mo>\n       ⁡\n       <!-- ⁡ -->\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n      <mo>\n       ,\n      </mo> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mrow class=\"MJX-TeXAtom-ORD\"> \n       <mo>\n        /\n       </mo> \n      </mrow> \n      <mi>\n       k\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle O(n),O(\\log n),O(n/k)}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 22.93ex; height: 2.84ex; vertical-align: -0.83ex;\" alt=\"O(n),O(\\log n),O(n/k)\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/59e3ada0f1e718e078e276500e07e46e7be3d893\" /></span>。","fragment_id":"基本概念_1","scratchTime":"2017-10-28 15:35:39.0","type":"leaf","flag":"fragment"},{"url":"","content":"布隆过滤器的原理是，当一个元素被加入集合时，通过K个<a title=\"散列函数\" class=\"mw-redirect\" href=\"/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\">散列函数</a>将这个元素映射成一个位<a title=\"数组\" href=\"/wiki/%E6%95%B0%E7%BB%84\">数组</a>中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。","fragment_id":"基本概念_2","scratchTime":"2017-10-28 15:35:39.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"优点","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       k\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle O(k)}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 4.83ex; height: 2.84ex; vertical-align: -0.83ex;\" alt=\"O(k)\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c\" /></span>）。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。","fragment_id":"优点_1","scratchTime":"2017-10-28 15:35:39.0","type":"leaf","flag":"fragment"},{"url":"","content":"<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       k\n      </mi> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle k}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 1.22ex; height: 2.17ex; vertical-align: -0.33ex;\" alt=\"k\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40\" /></span>和<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       m\n      </mi> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle m}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 2.05ex; height: 1.67ex; vertical-align: -0.33ex;\" alt=\"m\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/0a07d98bb302f3856cbabc47b2b9016692e3f7bc\" /></span>相同，使用同一组散列函数的两个布隆过滤器的交并<sup class=\"noprint Template-Fact\"><a title=\"Wikipedia:列明来源\" href=\"/wiki/Wikipedia:%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90\"><span title=\"来源请求。\" style=\"white-space: nowrap;\">[来源请求]</span></a></sup>运算可以使用位操作进行。","fragment_id":"优点_2","scratchTime":"2017-10-28 15:35:39.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"缺点","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。","fragment_id":"缺点_1","scratchTime":"2017-10-28 15:35:39.0","type":"leaf","flag":"fragment"},{"url":"","content":"<span id=\"外部链接\"></span><span class=\"mw-headline\" id=\".E5.A4.96.E9.83.A8.E9.93.BE.E6.8E.A5\">外部链接</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a title=\"编辑小节：外部链接\" href=\"/w/index.php?title=%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8&amp;action=edit&amp;section=4\">编辑</a><span class=\"mw-editsection-bracket\">]</span></span>","fragment_id":"缺点_2","scratchTime":"2017-10-28 15:35:39.0","type":"leaf","flag":"fragment"}]}]}