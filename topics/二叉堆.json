{"totalbranchlevel":2,"branchnum":3,"term_id":18,"name":"二叉堆","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"<b>二叉堆</b>是一种特殊的<a title=\"堆 (数据结构)\" href=\"/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\">堆</a>，二叉堆是<a title=\"完全二叉树\" class=\"mw-redirect\" href=\"/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91\">完全二叉树</a>或者是<a title=\"近似完全二叉树（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E8%BF%91%E4%BC%BC%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1\">近似完全二叉树</a>。二叉堆满足堆特性：父节点的<a title=\"键值（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E9%94%AE%E5%80%BC&amp;action=edit&amp;redlink=1\">键值</a>总是保持固定的序关系于任何一个子节点的键值，且每个节点的<a title=\"左子树（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E5%B7%A6%E5%AD%90%E6%A0%91&amp;action=edit&amp;redlink=1\">左子树</a>和<a title=\"右子树（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E5%8F%B3%E5%AD%90%E6%A0%91&amp;action=edit&amp;redlink=1\">右子树</a>都是一个二叉堆。","fragment_id":"摘要_1","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"当<a title=\"父节点（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E7%88%B6%E7%AF%80%E7%82%B9&amp;action=edit&amp;redlink=1\">父节点</a>的键值总是大于或等于任何一个<a title=\"子节点（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E5%AD%90%E8%8A%82%E7%82%B9&amp;action=edit&amp;redlink=1\">子节点</a>的键值时为<b><a title=\"最大堆（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E6%9C%80%E5%A4%A7%E5%A0%86&amp;action=edit&amp;redlink=1\">最大堆</a></b>。 当<a title=\"父节点（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E7%88%B6%E7%AF%80%E7%82%B9&amp;action=edit&amp;redlink=1\">父节点</a>的键值总是小于或等于任何一个<a title=\"子节点（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E5%AD%90%E8%8A%82%E7%82%B9&amp;action=edit&amp;redlink=1\">子节点</a>的键值时为<b><a title=\"最小堆（页面不存在）\" class=\"new\" href=\"/w/index.php?title=%E6%9C%80%E5%B0%8F%E5%A0%86&amp;action=edit&amp;redlink=1\">最小堆</a></b>。","fragment_id":"摘要_2","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"存储","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"二叉堆一般用<a title=\"数组\" href=\"/wiki/%E6%95%B0%E7%BB%84\">数组</a>来表示。如果根节点在数组中的位置是1，第<i>n</i>个位置的子节点分别在2<i>n</i>和 2<i>n</i>+1。因此，第1个位置的子节点在2和3，第2个位置的子节点在4和5。以此类推。这种基于1的数组存储方式便于寻找父节点和子节点。","fragment_id":"存储_1","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"1                        11\n      /   \\                      /  \\\n     2     3                   9     10\n    /  \\  /  \\                / \\   /  \\\n   4   5  6  7               5  6  7   8\n  / \\  / \\                  /\\  /\\\n 8  9 10 11               1  2 3  4","fragment_id":"存储_2","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":1,"facet_name":"基本操作","totalbranchnum":4,"type":"branch","totalleafnum":4,"children":[{"totalbranchlevel":0,"facet_name":"插入节点","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"在数组的最末尾插入新节点。然后自下而上调整子节点与父节点（称作up-heap或bubble-up, percolate-up, sift-up, trickle up, heapify-up, cascade-up操作）：比较当前节点与父节点，不满足<i>堆性质</i>则交换。从而使得当前子树满足二叉堆的性质。时间复杂度为O(log n)。","fragment_id":"插入节点_1","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"删除根节点","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"对于最大堆，删除根节点就是删除最大值；对于最小堆，是删除最小值。然后，把堆存储的最后那个节点移到填在根节点处。再从上而下调整父节点与它的子节点：对于最大堆，父节点如果小于具有最大值的子节点，则交换二者。这一操作称作down-heap或bubble-down, percolate-down, sift-down, trickle down, heapify-down, cascade-down,extract-min/max等。直至当前节点与它的子节点满足<i>堆性质</i>为止。","fragment_id":"删除根节点_1","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"下属对最大堆的自上而下调整堆的伪代码中，数组A的下标索引值是从1开始： <b>Max-Heapify</b><sup class=\"reference\" id=\"cite_ref-CLRS_1-0\"><a href=\"#cite_note-CLRS-1\">[1]</a></sup> (<i>A</i>, <i>i</i>):<br /> <span style=\"padding-left: 2em;\">&nbsp;</span><i>left</i> ← 2<i>i</i><br /> <span style=\"padding-left: 2em;\">&nbsp;</span><i>right</i> ← 2<i>i</i> + 1<br /> <span style=\"padding-left: 2em;\">&nbsp;</span><i>largest</i> ← <i>i</i><br /> <span style=\"padding-left: 2em;\">&nbsp;</span><b>if</b> <i>left</i> ≤ <i>heap_length</i>[<i>A</i>] <b>and</b> <i>A</i>[<i>left</i>] &gt; A[<i>largest</i>] <b>then</b>:<br /> <span style=\"padding-left: 4em;\">&nbsp;</span><i>largest</i> ← <i>left</i><br /> <span style=\"padding-left: 2em;\">&nbsp;</span><b>if</b> <i>right</i> ≤ <i>heap_length</i>[<i>A</i>] <b>and</b> <i>A</i>[<i>right</i>] &gt; <i>A</i>[<i>largest</i>] <b>then</b>:<br /> <span style=\"padding-left: 4em;\">&nbsp;</span><i>largest</i> ← <i>right</i><br /> <span style=\"padding-left: 2em;\">&nbsp;</span><b>if</b> <i>largest</i> ≠ <i>i</i> <b>then</b>:<br /> <span style=\"padding-left: 4em;\">&nbsp;</span><b>swap</b> <i>A[</i>i<i>] ↔</i> A<i>[</i>largest<i>]<br /></i> <span style=\"padding-left: 4em;\">&nbsp;</span>Max-Heapify(<i>A</i>, <i>largest</i>)","fragment_id":"删除根节点_2","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"构造二叉堆","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"","content":"一个直观办法是从单节点的二叉堆开始，每次插入一个节点。其时间复杂度为<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mi>\n       log\n      </mi> \n      <mo>\n       ⁡\n       <!-- ⁡ -->\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle O(n\\log n)}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 10.2ex; height: 2.84ex; vertical-align: -0.83ex;\" alt=\"O(n\\log n)\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/9d2320768fb54880ca4356e61f60eb02a3f9d9f1\" /></span>。","fragment_id":"构造二叉堆_1","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"最优算法是从一个节点元素任意放置的二叉树开始，自底向上对每一个子树执行删除根节点时的Max-Heapify算法（这是对最大堆而言）使得当前子树成为一个二叉堆。具体而言，假设高度为h的子树均已完成二叉堆化，那么对于高度为h+1的子树，把其根节点沿着最大子节点的分枝做调整，最多需要h步完成二叉堆化。可以证明，这个算法的时间复杂度为<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle O(n)}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 5.01ex; height: 2.84ex; vertical-align: -0.83ex;\" alt=\"O(n)\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a\" /></span>。","fragment_id":"构造二叉堆_2","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"建造最大堆的伪代码： <b>Build-Max-Heap</b><sup class=\"reference\" id=\"cite_ref-CLRS_1-1\"><a href=\"#cite_note-CLRS-1\">[1]</a></sup> (<i>A</i>):<br /> <span style=\"padding-left: 2em;\">&nbsp;</span><i>heap_length</i>[<i>A</i>] ← <i>length</i>[<i>A</i>]<br /> <span style=\"padding-left: 2em;\">&nbsp;</span><b>for</b> <i>i</i> ← <i>floor</i>(<i>length</i>[<i>A</i>]/2) <b>downto</b> 1 <b>do</b><br /> <span style=\"padding-left: 4em;\">&nbsp;</span><b>Max-Heapify</b>(<i>A</i>, <i>i</i>)","fragment_id":"构造二叉堆_3","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"合并两个二叉堆","totalbranchnum":0,"type":"branch","totalleafnum":6,"children":[{"url":"","content":"最优方法是把两个二叉堆首尾相连放在一个数组中，然后构造新的二叉堆。时间复杂度为<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       log\n      </mi> \n      <mo>\n       ⁡\n       <!-- ⁡ -->\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mi>\n       log\n      </mi> \n      <mo>\n       ⁡\n       <!-- ⁡ -->\n      </mo> \n      <mi>\n       k\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle O(\\log n\\log k)}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 13.4ex; height: 2.84ex; vertical-align: -0.83ex;\" alt=\"O(\\log n \\log k)\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/cd82b3f66ea1ef147fad0c317aa045743dd1e015\" /></span>，其中n、k为两个堆的元素数目。","fragment_id":"合并两个二叉堆_1","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"如果经常需要合并两个堆的操作，那么使用<a title=\"二项式堆\" class=\"mw-redirect\" href=\"/wiki/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%A0%86\">二项式堆</a>更好，其时间复杂度为<span class=\"mwe-math-element\"><span class=\"mwe-math-mathml-inline mwe-math-mathml-a11y\" style=\"display: none;\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\"> \n   <semantics> \n    <mrow class=\"MJX-TeXAtom-ORD\"> \n     <mstyle scriptlevel=\"0\" displaystyle=\"true\"> \n      <mi>\n       O\n      </mi> \n      <mo stretchy=\"false\">\n       (\n      </mo> \n      <mi>\n       log\n      </mi> \n      <mo>\n       ⁡\n       <!-- ⁡ -->\n      </mo> \n      <mi>\n       n\n      </mi> \n      <mo stretchy=\"false\">\n       )\n      </mo> \n     </mstyle> \n    </mrow> \n    <annotation encoding=\"application/x-tex\">\n     {\\displaystyle O(\\log n)}\n    </annotation> \n   </semantics> \n  </math></span><img class=\"mwe-math-fallback-image-inline\" aria-hidden=\"true\" style=\"width: 8.4ex; height: 2.84ex; vertical-align: -0.83ex;\" alt=\"O(\\log n)\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d\" /></span>。","fragment_id":"合并两个二叉堆_2","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"<span id=\"参见\"></span><span class=\"mw-headline\" id=\".E5.8F.82.E8.A7.81\">参见</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a title=\"编辑小节：参见\" href=\"/w/index.php?title=%E4%BA%8C%E5%8F%89%E5%A0%86&amp;action=edit&amp;section=7\">编辑</a><span class=\"mw-editsection-bracket\">]</span></span>","fragment_id":"合并两个二叉堆_3","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"<span id=\"外部链接\"></span><span class=\"mw-headline\" id=\".E5.A4.96.E9.83.A8.E9.93.BE.E6.8E.A5\">外部链接</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a title=\"编辑小节：外部链接\" href=\"/w/index.php?title=%E4%BA%8C%E5%8F%89%E5%A0%86&amp;action=edit&amp;section=8\">编辑</a><span class=\"mw-editsection-bracket\">]</span></span>","fragment_id":"合并两个二叉堆_4","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"<li id=\"cite_note-CLRS-1\"><span class=\"mw-cite-backlink\">^ <a href=\"#cite_ref-CLRS_1-0\"><span class=\"cite-accessibility-label\">跳转至： </span><sup><b>1.0</b></sup></a> <a href=\"#cite_ref-CLRS_1-1\"><sup><b>1.1</b></sup></a></span> <span class=\"reference-text\"><cite class=\"citation\" id=\"CITEREFCormenal.2001\">Cormen, T. H. &amp; al., Introduction to Algorithms 2nd, Cambridge, Massachusetts: The MIT Press, 2001, <a title=\"Special:网络书源/0-07-013151-1\" href=\"/wiki/Special:%E7%BD%91%E7%BB%9C%E4%B9%A6%E6%BA%90/0-07-013151-1\"><span title=\"国际标准书号\">ISBN</span>&nbsp;0-07-013151-1</a></cite><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fzh.wikipedia.org%3A%E4%BA%8C%E5%8F%89%E5%A0%86&amp;rft.au=al.&amp;rft.aufirst=T.+H.&amp;rft.aulast=Cormen&amp;rft.btitle=Introduction+to+Algorithms&amp;rft.date=2001&amp;rft.edition=2nd&amp;rft.genre=book&amp;rft.isbn=0-07-013151-1&amp;rft.place=Cambridge%2C+Massachusetts&amp;rft.pub=The+MIT+Press&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display: none;\">&nbsp;</span></span></span></li>","fragment_id":"合并两个二叉堆_5","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"},{"url":"","content":"<li><a class=\"external free\" href=\"http://mathworld.wolfram.com/Heap.html\" rel=\"nofollow\">http://mathworld.wolfram.com/Heap.html</a></li> \n<li><a class=\"external free\" href=\"http://www.policyalmanac.org/games/binaryHeaps.htm\" rel=\"nofollow\">http://www.policyalmanac.org/games/binaryHeaps.htm</a></li>","fragment_id":"合并两个二叉堆_6","scratchTime":"2017-10-28 15:31:26.0","type":"leaf","flag":"fragment"}]}]}]}