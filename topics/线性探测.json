{"totalbranchlevel":2,"branchnum":3,"term_id":4,"name":"线性探测","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":5,"children":[{"url":"","content":"<tbody>\n <tr> \n  <td class=\"mbox-image\"> \n   <div style=\"width: 52px;\">\n    <a class=\"image\" href=\"/wiki/File:Ambox_wikify.svg\"><img width=\"40\" height=\"40\" alt=\"Ambox wikify.svg\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Ambox_wikify.svg/40px-Ambox_wikify.svg.png\" data-file-height=\"620\" data-file-width=\"620\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Ambox_wikify.svg/60px-Ambox_wikify.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Ambox_wikify.svg/80px-Ambox_wikify.svg.png 2x\" /></a>\n   </div> </td> \n  <td class=\"mbox-text\"><span class=\"mbox-text-span\">本条目<b>部分链接不符合<a title=\"Wikipedia:LINKS\" class=\"mw-redirect\" href=\"/wiki/Wikipedia:LINKS\">格式手册</a>规范</b>。<a title=\"Wikipedia:MOSIW\" class=\"mw-redirect\" href=\"/wiki/Wikipedia:MOSIW\">跨语言链接</a>及章节标题等处的链接可能需要清理。<small><i>（2016年10月31日）</i></small> <span class=\"hide-when-compact\"><br /> <small>请协助<a class=\"external text\" href=\"//zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B&amp;action=edit\">改善</a>此条目。参见<a title=\"Wikipedia:格式手册/链接\" href=\"/wiki/Wikipedia:%E6%A0%BC%E5%BC%8F%E6%89%8B%E5%86%8C/%E9%93%BE%E6%8E%A5\">WP:LINKSTYLE</a>、<a title=\"Wikipedia:格式手册/链接\" href=\"/wiki/Wikipedia:%E6%A0%BC%E5%BC%8F%E6%89%8B%E5%86%8C/%E9%93%BE%E6%8E%A5#.E8.B7.A8.E8.AF.AD.E8.A8.80.E9.93.BE.E6.8E.A5\">WP:MOSIW</a>以了解细节。<a class=\"external text\" href=\"//zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B&amp;withCSS=MediaWiki:Extiw.css&amp;withJS=MediaWiki:Extiw.js&amp;oldid=42506891\">突出显示跨语言链接</a>可以便于检查。</small></span> </span></td> \n </tr> \n</tbody>","fragment_id":"摘要_1","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"},{"url":"","content":"<b>线性探测</b>是计算机程序解决<a title=\"散列表\" class=\"mw-redirect\" href=\"/wiki/%E6%95%A3%E5%88%97%E8%A1%A8\">散列表</a>冲突时所采取的一种策略。<a title=\"散列表\" class=\"mw-redirect\" href=\"/wiki/%E6%95%A3%E5%88%97%E8%A1%A8\">散列表</a>这种数据结构用于保存键值对，并且能通过给出的键来查找表中对应的值。线性探测这种策略是在1954年由<a title=\"吉恩&middot;阿姆达尔\" href=\"/wiki/%E5%90%89%E6%81%A9%C2%B7%E9%98%BF%E5%A7%86%E9%81%94%E7%88%BE\">Gene Amdahl</a>,&nbsp;<a title=\"en:Elaine M. McGraw\" class=\"extiw\" href=\"https://en.wikipedia.org/wiki/Elaine_M._McGraw\">Elaine M. McGraw</a>,和&nbsp;<a title=\"en:Arthur Samuel\" class=\"extiw\" href=\"https://en.wikipedia.org/wiki/Arthur_Samuel\">Arthur Samuel</a>&nbsp;所发明，并且最早于1963年由<a title=\"高德纳\" href=\"/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3\">Donald Knuth</a>对其进行分析。","fragment_id":"摘要_2","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"},{"url":"","content":"<div class=\"thumbinner\" style=\"width: 222px;\">\n <a href=\"https://en.wikipedia.org/wiki/File:HASHTB12.svg\"><img width=\"220\" height=\"137\" class=\"thumbimage\" alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/220px-HASHTB12.svg.png\" data-file-height=\"430\" data-file-width=\"690\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/330px-HASHTB12.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/440px-HASHTB12.svg.png 2x\" /></a> \n <div class=\"thumbcaption\"> \n  <div class=\"magnify\">\n   <a title=\"放大\" class=\"internal\" href=\"/wiki/File:HASHTB12.svg\"></a>\n  </div> \n  <span lang=\"en\" xml:lang=\"en\">John Smith</span>和\n  <span lang=\"en\" xml:lang=\"en\">Sandra Dee</span>（都被杂凑映射到了单元873）的冲突，借由把后者放在下一个空闲单元（单元874）而解决\n </div> \n</div>","fragment_id":"摘要_3","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"},{"url":"","content":"与<a title=\"en:Quadratic probing\" class=\"extiw\" href=\"https://en.wikipedia.org/wiki/Quadratic_probing\">二次探测</a>和<a title=\"en:Double hashing\" class=\"extiw\" href=\"https://en.wikipedia.org/wiki/Double_hashing\">双散列</a>一样，线性探测是一种<a title=\"en:Open addressing\" class=\"extiw\" href=\"https://en.wikipedia.org/wiki/Open_addressing\">开放寻址</a>的策略。在这些策略里，散列表的每个单元都存储一对键值对。当散列函数对一个给定值产生一个键，并且这个键指向散列表中某个已经被另一个键值对所占用的单元时，线性探测用于解决此时产生的冲突：查找散列表中离冲突单元最近的空闲单元，并且把新的键插入这个空闲单元。同样的，查找也同插入如出一辙：从散列函数给出的散列值对应的单元开始查找，直到找到与键对应的值或者是找到空单元。","fragment_id":"摘要_4","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"},{"url":"","content":"正如Thorup和张寅在2012年所写，…“散列表是最常用的普通数据结构，它在硬件上的标准实现中最流行的方法就是使用线性探测。线性探测又快又简单。<sup class=\"reference\" id=\"cite_ref-tz12_1-0\"><a href=\"#cite_note-tz12-1\">[1]</a></sup>”线性探测能够提供高性能的原因是因为它的良好的引用局部性，然而它与其他解决散列冲突的策略相比对于散列函数的质量更为敏感。当使用随机散列函数， <a title=\"en:K-independent hashing\" class=\"extiw\" href=\"https://en.wikipedia.org/wiki/K-independent_hashing\">5-independent散列函数</a>或<a title=\"en:Tabulation hashing\" class=\"extiw\" href=\"https://en.wikipedia.org/wiki/Tabulation_hashing\">tabulation散列函数</a>，其用于搜索，插入或删除的预期时间是常数。不过，借由其他像是<a title=\"Murmur哈希\" href=\"/wiki/Murmur%E5%93%88%E5%B8%8C\">私语杂凑</a>的散列函数可以在实作中达到较好的结果<sup class=\"reference\" id=\"cite_ref-richter15_2-0\"><a href=\"#cite_note-richter15-2\">[2]</a></sup>。","fragment_id":"摘要_5","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":1,"facet_name":"操作","totalbranchnum":3,"type":"branch","totalleafnum":3,"children":[{"totalbranchlevel":0,"facet_name":"搜索","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"为了搜索给定的键 x，散列表中由h(x)对应的单元开始的相邻单元&nbsp;<i>h</i>(<i>x</i>) + 1,&nbsp;<i>h</i>(<i>x</i>) + 2, ..., 都将被检查，直到找到了内容为空的单元或是找到了存储给定键为x的单元。其中，h是散列函数。如果找到了存储给定键的单元，搜索将会返回单元中存储的键对应的值。否则，如果搜索遇到了空的单元，键在表中就不存在，因为键应当被存放在所有未被搜索的单元之前。此时，搜索返回表中无此键的结果。","fragment_id":"搜索_1","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"插入","totalbranchnum":0,"type":"branch","totalleafnum":2,"children":[{"url":"","content":"为了在表中插入一对键值对<span lang=\"en\" style=\"font-family: serif;\" xml:lang=\"en\"><span class=\"texhtml\">(<i>x</i>,<i>v</i>)</span></span> （有可能会替换有着相同键的键值对），插入算法也会访问搜索算法访问的同一系列单元，直到找到一个空的单元，或是找到了存储给定键为x的单元。新的键值对将会存储在此单元中。","fragment_id":"插入_1","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"},{"url":"","content":"如果插入将导致表（占用单元的比例）增长高于某个预设的阈值的负载系数，整个表可以通过一个新的表（规模大于本表规模）和一个新的散列函数来代替，如使用动态数组。设置这个的阈值接近于零，并使用表大小的高增长率来带来更快速的哈希表的操作，但相比于接近一个阈值与低增长率，它会带来更高的内存使用情况。一个常见的选择是表规模扩大一倍，当负载系数将超过1/2，导致负载系数保持在1/4和1/2之间。","fragment_id":"插入_2","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"}]},{"totalbranchlevel":0,"facet_name":"删除","totalbranchnum":0,"type":"branch","totalleafnum":3,"children":[{"url":"","content":"<div class=\"thumbinner\" style=\"width: 222px;\">\n <a href=\"https://en.wikipedia.org/wiki/File:Linear_Probing_Deletion.png\"><img width=\"220\" height=\"65\" class=\"thumbimage\" alt=\"\" src=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/38/Linear_Probing_Deletion.png/220px-Linear_Probing_Deletion.png\" data-file-height=\"316\" data-file-width=\"1077\" srcset=\"//upload.wikimedia.org/wikipedia/commons/thumb/3/38/Linear_Probing_Deletion.png/330px-Linear_Probing_Deletion.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/38/Linear_Probing_Deletion.png/440px-Linear_Probing_Deletion.png 2x\" /></a> \n <div class=\"thumbcaption\"> \n  <div class=\"magnify\">\n   <a title=\"放大\" class=\"internal\" href=\"/wiki/File:Linear_Probing_Deletion.png\"></a>\n  </div> 当一对键值对被删除，可能会有必要将其他的键值对放回到它的单元中，来防止搜索时搜索到空的单元。\n </div> \n</div>","fragment_id":"删除_1","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"},{"url":"","content":"相较于直接清空对应单元i，更好的做法是先清空，然后把它之后所有会造成问题的单元向前移动，来避免搜索出错。重复直到出现空单元，则删除动作安全完成。但是，如果有发现后续有键可以移到这个位置上的话，直接将该键取代欲删除的单元可以加速后续的其他行为，当然，这样也会造成后面多出一个新的空单元。搜索可用来取代的单元的动作会持续到搜索到原本就空白的单元为止。在这个将键移到前面的过程中，所有的键都会被算过一遍。因此，完成这整个过程所需的时间与该储存位置的单元数量呈正比，与杂凑表的其他运算相符<sup class=\"reference\" id=\"cite_ref-gt_3-1\"><a href=\"#cite_note-gt-3\">[3]</a></sup>。","fragment_id":"删除_2","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"},{"url":"","content":"有一种可行的替代方案是<a title=\"懒惰删除\" href=\"/wiki/%E6%87%92%E6%83%B0%E5%88%A0%E9%99%A4\">懒惰删除</a>，用指向欲删除键的特殊的<b>标志值</b>（flag value）取代原本的键值配对。不过，这些标志值在搜索上会当作非空。因此，如果一个阵列中有过多的被删除键，那么就需要清除所有的标志值并且重新杂凑整个表<sup class=\"reference\" id=\"cite_ref-gt_3-2\"><a href=\"#cite_note-gt-3\">[3]</a></sup><sup class=\"reference\" id=\"cite_ref-morin_4-1\"><a href=\"#cite_note-morin-4\">[4]</a></sup>。","fragment_id":"删除_3","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"}]}]},{"totalbranchlevel":0,"facet_name":"注解与参考文献","totalbranchnum":0,"type":"branch","totalleafnum":1,"children":[{"url":"","content":"<ol class=\"references\"> \n <li id=\"cite_note-tz12-1\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-tz12_1-0\"><span class=\"cite-accessibility-label\">跳转 </span>^</a></b></span> <span class=\"reference-text\"><cite class=\"citation\" id=\"CITEREFThorupZhang2012\">Thorup, Mikkel; Zhang, Yin, Tabulation-based 5-independent hashing with applications to linear probing and second moment estimation, SIAM Journal on Computing, 2012, <b>41</b> (2): 293–331, <a class=\"external text\" href=\"//www.ams.org/mathscinet-getitem?mr=2914329\" rel=\"nofollow\"><span title=\"数学评论\">MR&nbsp;2914329</span></a>, <a class=\"external text\" href=\"//dx.doi.org/10.1137%2F100800774\" rel=\"nofollow\"><span title=\"数位物件识别号\">doi:10.1137/100800774</span></a></cite><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fzh.wikipedia.org%3A%E7%BA%BF%E6%A7%E6%8E%A2%E6%B5&amp;rft.atitle=Tabulation-based+5-independent+hashing+with+applications+to+linear+probing+and+second+moment+estimation&amp;rft.au=Zhang%2C+Yin&amp;rft.aufirst=Mikkel&amp;rft.aulast=Thorup&amp;rft.date=2012&amp;rft.genre=article&amp;rft.issue=2&amp;rft.jtitle=SIAM+Journal+on+Computing&amp;rft.pages=293-331&amp;rft.volume=41&amp;rft_id=%2F%2Fwww.ams.org%2Fmathscinet-getitem%3Fmr%3D2914329&amp;rft_id=info%3Adoi%2F10.1137%2F100800774&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal\" class=\"Z3988\"><span style=\"display: none;\">&nbsp;</span></span>.</span></li> \n <li id=\"cite_note-richter15-2\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-richter15_2-0\"><span class=\"cite-accessibility-label\">跳转 </span>^</a></b></span> <span class=\"reference-text\"><cite class=\"citation\" id=\"CITEREFRichterAlvarezDittrich2015\">Richter, Stefan; Alvarez, Victor; Dittrich, Jens, A seven-dimensional analysis of hashing methods and its implications on query processing, Proceedings of the VLDB Endowment, 2015, <b>9</b> (3): 293–331</cite><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fzh.wikipedia.org%3A%E7%BA%BF%E6%A7%E6%8E%A2%E6%B5&amp;rft.atitle=A+seven-dimensional+analysis+of+hashing+methods+and+its+implications+on+query+processing&amp;rft.au=Alvarez%2C+Victor&amp;rft.au=Dittrich%2C+Jens&amp;rft.aufirst=Stefan&amp;rft.aulast=Richter&amp;rft.date=2015&amp;rft.genre=article&amp;rft.issue=3&amp;rft.jtitle=Proceedings+of+the+VLDB+Endowment&amp;rft.pages=293-331&amp;rft.volume=9&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal\" class=\"Z3988\"><span style=\"display: none;\">&nbsp;</span></span>.</span></li> \n <li id=\"cite_note-gt-3\"><span class=\"mw-cite-backlink\">^ <a href=\"#cite_ref-gt_3-0\"><span class=\"cite-accessibility-label\">跳转至： </span><sup><b>3.0</b></sup></a> <a href=\"#cite_ref-gt_3-1\"><sup><b>3.1</b></sup></a> <a href=\"#cite_ref-gt_3-2\"><sup><b>3.2</b></sup></a></span> <span class=\"reference-text\"><cite class=\"citation\" id=\"CITEREFGoodrichTamassia2015\"><a title=\"Michael T. Goodrich（页面不存在）\" class=\"new\" href=\"/w/index.php?title=Michael_T._Goodrich&amp;action=edit&amp;redlink=1\">Goodrich, Michael T.</a>; <a title=\"Roberto Tamassia（页面不存在）\" class=\"new\" href=\"/w/index.php?title=Roberto_Tamassia&amp;action=edit&amp;redlink=1\">Tamassia, Roberto</a>, Section 6.3.3: Linear Probing, Algorithm Design and Applications, Wiley: 200–203, 2015</cite><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fzh.wikipedia.org%3A%E7%BA%BF%E6%A7%E6%8E%A2%E6%B5&amp;rft.atitle=Section+6.3.3%3A+Linear+Probing&amp;rft.au=Tamassia%2C+Roberto&amp;rft.aufirst=Michael+T.&amp;rft.aulast=Goodrich&amp;rft.btitle=Algorithm+Design+and+Applications&amp;rft.date=2015&amp;rft.genre=bookitem&amp;rft.pages=200-203&amp;rft.pub=Wiley&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display: none;\">&nbsp;</span></span>.</span></li> \n <li id=\"cite_note-morin-4\"><span class=\"mw-cite-backlink\">^ <a href=\"#cite_ref-morin_4-0\"><span class=\"cite-accessibility-label\">跳转至： </span><sup><b>4.0</b></sup></a> <a href=\"#cite_ref-morin_4-1\"><sup><b>4.1</b></sup></a></span> <span class=\"reference-text\"><cite class=\"citation\" id=\"CITEREFMorin2014\">Morin, Pat, Section 5.2: LinearHashTable: Linear Probing, <a class=\"external text\" href=\"http://opendatastructures.org/\" rel=\"nofollow\">Open Data Structures (in pseudocode)</a> 0.1G<i>β</i>: 108–116, February 22, 2014 <span class=\"reference-accessdate\">[<span class=\"nowrap\">2016-01-15</span>]</span></cite><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fzh.wikipedia.org%3A%E7%BA%BF%E6%A7%E6%8E%A2%E6%B5&amp;rft.atitle=Section+5.2%3A+LinearHashTable%3A+Linear+Probing&amp;rft.aufirst=Pat&amp;rft.aulast=Morin&amp;rft.btitle=Open+Data+Structures+%28in+pseudocode%29&amp;rft.date=2014-02-22&amp;rft.edition=0.1G%27%27%26beta%3B%27%27&amp;rft.genre=bookitem&amp;rft.pages=108-116&amp;rft_id=http%3A%2F%2Fopendatastructures.org%2F&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"><span style=\"display: none;\">&nbsp;</span></span>.</span></li> \n</ol>","fragment_id":"注解与参考文献_1","scratchTime":"2017-10-28 15:29:28.0","type":"leaf","flag":"fragment"}]}]}