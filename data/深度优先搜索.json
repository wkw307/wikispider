{"totalbranchlevel":2,"branchnum":2,"term_id":58,"name":"深度优先搜索","children":[{"totalbranchlevel":0,"facet_name":"摘要","totalbranchnum":0,"type":"branch","totalleafnum":7,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"本条目需要精通或熟悉相关主题的编者参与及协助编辑。（2013年5月1日） 请邀请适合的人士改善本条目。更多的细节与详情请参见讨论页。","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"深度优先搜索 节点进行深度优先搜索的顺序 概况 类别： 搜索算法 数据结构： 图 时间复杂度： O ( b m ) {\\displaystyle O(b^{m})} 空间复杂度： O ( b m ) {\\displaystyle O(bm)} 最佳解： 否 完全性： 是 其他： b - 分支系数 m - 图的最大深度","fragment_id":"摘要_2","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"图与树 搜索算法 α–β A* B* 回溯 集束 贝尔曼-福特 最佳优先 双向 Borůvka 分支限界 BFS 大英博物馆 D* DFS 深度限制 迪杰斯特拉 Edmonds Floyd–Warshall 边缘搜索 爬山 IDA* 迭代加深 Johnson 跳点 克鲁斯克尔 字典序BFS 普里姆 SMA* 分类 图算法 搜索算法 相关主题 动态规划 图的遍历 树的遍历 查 论 编","fragment_id":"摘要_3","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。","fragment_id":"摘要_4","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。","fragment_id":"摘要_5","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"因发明“深度优先搜索算法”，约翰·霍普克洛夫特与罗伯特·塔扬共同获得计算机领域的最高奖：图灵奖。[来源请求]","fragment_id":"摘要_6","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"//upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Depth-first-tree.svg/300px-Depth-first-tree.svg.png","fragment_id":"摘要_1","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"image"}]},{"totalbranchlevel":0,"facet_name":"C++的实现","totalbranchnum":0,"type":"branch","totalleafnum":7,"children":[{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"定义一个结构体来表达一个NODE的结构：","fragment_id":"C++的实现_1","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"struct Node \n{\n   int self; //数据 \n   Node *left; //左节点 \n   Node *right; //右节点 \n};","fragment_id":"C++的实现_2","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"那么我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：","fragment_id":"C++的实现_3","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"“                  A\n           B           C\n      D   E          F   G\n ”","fragment_id":"C++的实现_4","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"A是第一个访问的，然后顺序是B和D、然后是E。然后再是C、F、G。那么我们怎么来保证这个顺序呢？","fragment_id":"C++的实现_5","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"这里就应该用堆叠的结构，因为堆叠是一个先进后出的顺序。通过使用C++的STL，下面的程序能帮助理解：","fragment_id":"C++的实现_6","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"},{"url":"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2","content":"const int TREE_SIZE = 9;\nstd::stack<Node*> unvisited; \nNode nodes[TREE_SIZE]; \nNode* current;\n\n//初始化树\nfor(int i=0; i<TREE_SIZE; i++)\n{\n  nodes[i].self = i;\n  int child = i*2+1;\n  if(child<TREE_SIZE) // Left child\n    nodes[i].left = &nodes[child];\n  else\n    nodes[i].left = NULL;\n  child++;\n  if(child<TREE_SIZE) // Right child    \n    nodes[i].right = &nodes[child];\n  else\n    nodes[i].right = NULL;\n}           \n\nunvisited.push(&nodes[0]); //先把0放入UNVISITED stack\n\n// 只有UNVISITED不空\nwhile(!unvisited.empty())\n{\n  current=(unvisited.top()); //当前应该访问的\n  unvisited.pop(); \n  if(current->right!=NULL) \n    unvisited.push(current->right); // 把右边压入 因为右边的访问次序是在左边之后\n  if(current->left!=NULL) \n    unvisited.push(current->left);\n  cout<<current->self<<endl;\n}","fragment_id":"C++的实现_7","scratchTime":"2016-12-20 09:47:09.0","type":"leaf","flag":"text"}]}]}
